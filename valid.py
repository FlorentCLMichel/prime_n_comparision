import os
from typing import List,Dict,Tuple
import sys
import matplotlib.pyplot as plt
from zipfile import ZipFile
from datetime import timedelta
import math
def get_all_benchmark_files(pattern:str)->List[str]:
    return [obj for obj in os.listdir(None) if obj.startswith(pattern)]

def unzip(path:str):
    with ZipFile(path) as zfile:
        zfile.extractall()

def get_primes(file:str)->set:
    with open(file) as file_o:
        data = file_o.readlines()
    return {i.split(",")[0] for i in data}

def load_primes(file:str,skip_header=False)->Dict[str,Tuple[str,str]]:
    primes = {}
    with open(file) as prime_file:
        data = prime_file.readlines()
    if skip_header:
            data=data[1:]
    for i in data:
        n_prime, prime, time = i.split(",")
        primes[int(n_prime)]=(int(prime),float(time.strip()))
    return primes

def add_table_readme_content(metrics:List[Tuple[str,int,float]])->str:
    content = """# RUST v/s PYTHON

Benchmark graph that compares speed of Pythona and Rust by generating prime numbers.

![Benchmark image](./output.jpg)
Note: The above graph is autogenerated for every github action run. Tweak the parameters in workflow run to get different graph for number of primes.

|Language|nth prime|time taken|
|---|---|---|"""
    
    for m in metrics:
        content=content+f"\n|{m[0]}|{m[1]}|{round(m[2]/1000000000,3)}s|"
    return content

def main():
    benchmark_lang = sys.argv[1] if len(sys.argv)>1 else None
    benchmark_pattern = "benchmark_"
    unzip("./1m.csv.zip")
    benchmark_files = (benchmark_lang and [f"{benchmark_pattern}{benchmark_lang}"]) or get_all_benchmark_files(benchmark_pattern)
    one_m_primes = load_primes("./1m.csv",skip_header=True)
    plt.figure(figsize=(15,8))
    n_th_prime_time = []
    for file in benchmark_files:
        is_valid=True
        lang = file.replace(benchmark_pattern,'')
        print(f"Validating {lang}")
        b_primes = load_primes(file)
        b_primes_items = list(b_primes.items())
        for n_prime, prime_time in b_primes_items:
            one_m_prime_val = one_m_primes.get(n_prime)
            if not one_m_prime_val:
                print("Only first one million primes can be validated. Skipping the file.")
                break
            if prime_time[0]!=one_m_prime_val[0]:
                print(f"{n_prime}th prime should be {one_m_prime_val[0]} but got {prime_time[0]}.")
                break
        if not is_valid:
            print("Not OK \n")
            continue
        print("OK \n")
        
        n_th_prime_time.append((lang, b_primes_items[-1][0],b_primes_items[-1][1][1]))
        X = list(map(lambda x: x[0],b_primes_items))
        Y = list(map(lambda x: x[1][1],b_primes_items))
        plt.xticks(rotation = 25)
        plt.xscale('log')
        plt.yscale('log')
        plt.ylabel("Time(ns)")
        plt.xlabel("No. of Primes generated")
        plt.plot(X,Y,label=lang)

    readme_content = add_table_readme_content(n_th_prime_time)
    with open("README.md","w") as file:
        file.write(readme_content)

    plt.legend()
    plt.savefig("output.jpg")



    
if __name__=="__main__":
    main()
